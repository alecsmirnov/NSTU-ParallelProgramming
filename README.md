# Лабораторные работы по дисциплине "Параллельное программирование" на факультете ПМИ, НГТУ
&nbsp;  

## 1. Программирование независимых потоков
### Условия задачи

Вводная часть:  
1) Доработать программу из *примера 2* в методическом указании.
2) Оценить стоимость запуска одного потока операционной системой. Изменяя количество операций (можно использовать любую арифметическую 
операцию), которые исполняет функция потока, определить такое их количество, чтобы порождение потока было оправданным.
3) Разработать программу, которая обеспечивает параллельное применение заданной функции к каждому элементу массива. Размер массива, 
применяемая функция и количество потоков задаются динамически.

Задание для самостоятельной работы:  
Создать упрощенный *HTTP-сервер*, отвечающий на любой запрос клиента (например, браузера) строкой «Request number <номер запроса> 
has been processed», где под номером запроса понимается порядковый номер, присвоенный запросу сервером. Нумерация начинается с единицы.
1) Доработать однопоточную версию сервера, доступную по адресу: http://rosettacode.org/wiki/Hello_world/Web_server#C. Обработка 
каждого запроса выполняется в отдельном потоке: при получении запроса создается новый поток для его обработки, после отправки результата 
клиенту поток завершает свою работу. Соединение с клиентом закрывается сразу после обработки запроса.
2) Оценить производительность сервера с помощью утилиты **ab4**, входящей в комплект поставки веб-сервера Apache.
3) Оценить максимальное количество потоков, с которым может работать сервер, для различных размеров стека по умолчанию (2 Мбайт, 1 Мбайт, 512 Кбайт).
4) Добавить в обработчик запроса от клиента запуск простейшего PHP-скрипта, возвращающего версию PHP (\<?php echo phpversion();?\>). 
Вернуть номер версии клиенту. Оценить изменение производительности сервера с помощью утилиты ab.  
&nbsp;  


## 2. Программирование взаимодействующих потоков
### Условия задачи

Вводная часть:  
1) Добавить в *пример 4* вывод информации о том, какой поток какую задачу взял на исполнение, а также некоторое достаточно продолжительное вычисление в функцию **do_task()**. Проверить, что все задачи выполняются, причем каждая – не более одного раза. Отключить вызовы функций **pthread_mutex_lock()** и **pthread_mutex_unlock()** и убедиться, что при отсутствии мьютекса некоторые задачи будут выполняться дважды, тогда как другие не выполнятся ни разу.
2) Сравнить скорости работы примитивов синхронизации – мьютекса и спинлока. Выяснить, как количество потоков, одновременно обращающихся к ресурсу, защищенному примитивом синхронизации, влияет на скорость исполнения программы.
3) Реализовать условную переменную с помощью мьютекса и цикла ожидания.
4) Реализовать функцию для выполнения вычислений по модели **MapReduce**. Подробную информацию о модели MapReduce можно найти в электронном документе: [*Калита Р.* MapReduce](http://regfordev.blogspot.com/2015/09/mapreduce.html#.XmUX76gzaCo "Блог о разработке, программировании на С#/.NET, и не только."). В качестве параметров функция должна принимать массив данных для обработки, имена функций **map** и **reduce**, количество разрешенных потоков. В качестве реализации параллельного применения функции **map** к каждому элементу массива использовать результаты *пункта 3* порядка выполнения *лабораторной работы № 1*. Реализовать параллельное применение функции **reduce** к списку, полученному в результате работы функции **map**.

Задание для самостоятельной работы:  
Пул потоков – это набор потоков, которые могут использоваться для решения различных задач. Задачи помещаются в общую очередь. Свободный поток (поток, который не решает в настоящий момент никакую задачу) обращается к очереди для получения очередной задачи, выполняет ее, после чего запрашивает в очереди следующую задачу. В результате исполнения некоторой задачи могут появляться новые задачи. Они также добавляются в очередь. Программа завершается, когда в очереди не остается задач и все потоки оказываются свободными.  

Необходимо реализовать пул потоков и на его основе решить задачу: генерации простых чисел с помощью алгоритма «Решето Эратосфена»

